## JVM：类加载的过程

![](../resource/image/Cgq2xl6O2nSAXgX1AAAk3WIjy2w291.png)

#### 装载

装载就是 Java 虚拟机查找 class 文件，并通过字节流读取文件，然后创建 Class 对象的过程。

1. 读取 class 文件，并生成二进制字节流
2. 将字节流解析为 JVM 内部特定的数据结构，并保存在方法区。
3. 在堆内存中创建 Class 类，作为方法区数据访问的入口。

#### 链接

##### 验证

验证的目的是为了确定 class 文件中包含的信息是否符合虚拟机的规范，并且不会危及对虚拟机的安全。

1. 文件格式检验，检验字节流是否符合 class 文件的规范，以及是否能被当前版本的虚拟机处理。

   - 是否以魔数 0xCAFEBABE 开头
   - 主、次版本号是否在当前虚拟机的处理范围之内
   - 常量池中是否有非法的 tag 标志等等

2. 元数据检验，对 class 文件的描述信息进行语义分析，以确保其符合 Java 语言规范。

   - 这个类是否有父类（除了 Object 所有的类都应该有父类）
   - 这个类是否继承了不允许被修饰的类
   - 如果这个类不是抽象类，是否实现了父类或者接口中所有的方法等等

3. 字节码检验，通过对数据流和控制流的分析，验证程序是否合法。

   - 在操作数栈中放入了一个 int 变量，使用的时候却按照 long 类型加载到了局部变量表中
   - 跳转指令（switch、break 等）是否会跳转到方法体以外的字节码上
   - 把一个对象赋值给了另一个和它完全没有关系的数据类型上等等

4. 符号引用检验，对常量池中的各种符号引用进行匹配性校验，以保证解析动作的正常执行

   符号引用通过一组符号来描述所引用的目标，看上去就是一个字符串例如 `Foo.print:()V`，可以分为下面几类：

   - 类和接口的全限定名
   - 字段的名称和描述符
   - 方法的名称和描述符

   符号引用的检验，就是为了检查其描述的类、字段、方法是否真的存在且与描述一致，以及它们的是否能被当前类所访问。

##### 准备

这个阶段会为代码中的 static 变量分配内存，并将其设置为 0 值、false 或者 null，它们真的值会在初始化阶段设置。

但是对于 static final 类型的变量会在这个阶段设置真正的值。

##### 解析

这个阶段会将符号引用转换为直接引用，也就是内存中的地址。

这个内存指的是堆内存，在之前 Class 类已经创建好了。

#### 初始化

在这个阶段会执行 static 变量的赋值语句和 static 代码块，非 static 修饰的语句只会在实例化对象的时候执行。

例如 `Foo.value = 1` 这行代码是不会执行 Foo 的构造方法以及普通代码块的。

面试题：

```java
// 父类
public class Parent {

    public static String ID = "12345";

    static {
        System.out.println("Parent init");
    }
}
// 子类
public class Child extends Parent {
    static {
        System.out.println("Child init");
    }
}

// main 方法
public class Test {

    public static void main(String[] args) {
        System.out.println(Child.ID); // 这行代码会输出什么
    }
}
```

答案如下：

```
Parent init
12345
```

在子类中调用父类的 static，只会对父类初始化，不会初始化子类。

如果是用 static final 修饰，也不会调用父类的初始化。

在 Java 中类的初始化顺序如下：

静态变量/静态代码块 -> 普通变量/普通代码块 -> 构造函数

1. 父类静态变量和静态代码块
2. 子类静态变量和静态代码块
3. 父类普通成员变量和普通代码块
4. 父类的构造函数
5. 子类普通成员变量和普通代码块
6. 子类的构造函数



